{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"getting-started/installation/","title":"Prerequisites","text":"<p>You will need Python installed and your favorite package and environment manager. This guide will use Poetry. If you do not have Poetry installed, you can install it by following the official installation guide.</p> <p>You will also need to have Docker installed to follow most of the future tutorials.</p>"},{"location":"getting-started/installation/#create-a-new-poetry-project","title":"Create a New Poetry Project","text":"<p>Run the following command to create a new Poetry project: <pre><code>poetry new my_project\n</code></pre> Replace <code>my_project</code> with the desired name of your project.</p> <p>Move into the newly created project directory: <pre><code>cd my_project\n</code></pre></p> <p>Poetry automatically manages a virtual environment for your project. To activate it, run: <pre><code>poetry shell\n</code></pre></p>"},{"location":"getting-started/installation/#install-the-library","title":"Install the Library","text":"<p>Use Poetry to add the library as a dependency: <pre><code>poetry add reagent[cli]\n</code></pre></p> <p>This will also include the Reagent CLI which we will use for the tutorials.</p>"},{"location":"getting-started/philosophy/","title":"Agents?","text":"<p>With all the hype in the industry I think it is important to define the overloaded term \"agent\". An AI agent is simply utilizing generative AI to complete a task. That task can be anything.</p> <ul> <li>Chatbot: Have a conversation with the user</li> <li>Copilot: Help the user write code</li> <li>Custom: Every time a Salesforce record is created write me an email describing it</li> </ul> <p>As you can see, most of the use cases for agents have not strayed too far from the ability of an LLM to choose an appropriate tool or write some text. At least not yet. That is where Reagent comes in. We believe that with the proper utilization and checks LLM's can greatly surpass the trivial tasks they are used for nowadays.</p>"},{"location":"getting-started/philosophy/#philosophy","title":"Philosophy","text":"<p>Reagent was built with 4 core principles in mind when it comes to the construction of agents.</p> <ul> <li>Informed Decision: Agents should be given as much information as possible to make decisions</li> <li>Fast Feedback: Agents should receive validation of actions taken as quickly as possible</li> <li>Monotonic Decomposition: Agents should always be able to make progress on a task by decomposing it into smaller tasks</li> <li>Don't Know: Agents should be able to say they don't know when they don't have the information or tools to complete a task</li> </ul>"},{"location":"getting-started/quick-start/","title":"Prerequisites","text":"<p>If you followed the installation guide you should now have a python project with Reagent installed and Docker on your system.</p> <p>At the very least, Reagent needs a Postgres database to work properly. Future guides will show you how to setup other infrastructure to extend Reagent's capabilities. First let's setup a local Postgres database.</p>"},{"location":"getting-started/quick-start/#setting-up-postgres","title":"Setting Up Postgres","text":""},{"location":"getting-started/quick-start/#step-1-create-a-composeyaml-file","title":"Step 1. Create a <code>compose.yaml</code> File","text":"<p>Before starting, let's organize our project by creating a dedicated folder for Docker-related files. Inside that folder create a file named <code>compose.yaml</code>.</p> <pre><code>your-project/\n\u251c\u2500\u2500 docker/\n\u2502   \u2514\u2500\u2500 compose.yaml\n\u251c\u2500\u2500 your-project/\n\u251c\u2500\u2500 tests\n\u2514\u2500\u2500 pyproject.toml\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-configure-composeyaml","title":"Step 2: Configure <code>compose.yaml</code>","text":"<p>Add the following contents to the compose file.</p> <pre><code>services:\n  app_postgres:\n    image: postgres:15.6\n    command: postgres -c 'max_connections=200'\n    restart: always\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n      - POSTGRES_DB=app\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -d app -U postgres\"]\n      interval: 10s\n      timeout: 10s\n      retries: 5\n      start_period: 10s\n    ports:\n      - \"5432:5432\"\n\nvolumes:\n    postgres_data:\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-start-the-postgresql-container","title":"Step 3: Start the PostgreSQL Container","text":"<p>Run the following command in the directory containing your <code>compose.yaml</code> file:</p> <pre><code>docker-compose -f compose.yaml up\n</code></pre> <p>This will download the PostgreSQL image (if not already available) and start the container.</p>"},{"location":"getting-started/quick-start/#environment-setup","title":"Environment Setup","text":"<p>Reagent uses environment variables to configure itself. These variables can be provided from a variety of sources, but for local development the most convenient is a .env file. Create the .env file in the root of your project.</p> <p><pre><code>your-project/\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 pyproject.toml\n</code></pre> Place the Postgres container's configuration in the file.  <pre><code>POSTGRES__HOST=\"localhost\"\nPOSTGRES__PORT=\"5432\"\nPOSTGRES__USER=\"postgres\"\nPOSTGRES__PASSWORD=\"postgres\"\nPOSTGRES__DB=\"app\"\n</code></pre></p> Note <p>Those are double underscores in the variable name. This delimiter helps <code>pydantic-settings</code> load a nested configuration.</p> Warning <p>Reagent uses <code>python-dotenv</code> to load .env configuration. Any configuration in your .env file will override environment variables set through any other method.</p>"},{"location":"getting-started/quick-start/#the-good-stuff","title":"The Good Stuff","text":"<p>Even though Reagent is built for complex agents, let's start with the simplest of all agents: the chatbot. The chatbot has one task, respond to the user. Creating a chatbot is incredibly easy with Reagent.</p>"},{"location":"getting-started/quick-start/#cleanup","title":"Cleanup","text":"<p>When you're done with your work, you should stop the Docker containers to free up resources:</p>"},{"location":"getting-started/quick-start/#using-ctrlc","title":"Using Ctrl+C","text":"<p>If the Docker Compose process is running in the foreground, you can press Ctrl+C in your terminal to stop the containers.</p>"},{"location":"getting-started/quick-start/#using-docker-compose-down-command","title":"Using Docker Compose Down Command","text":"<p>To completely stop and remove the containers, networks, and volumes defined in your compose file, run:</p> <pre><code>docker-compose -f compose.yaml down\n</code></pre> <p>If you want to preserve your PostgreSQL data for future use but stop the containers, use:</p> <pre><code>docker-compose -f compose.yaml stop\n</code></pre>"}]}